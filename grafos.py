# -*- coding: utf-8 -*-
"""Grafos.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1k2xbRKy1_AaXKHZ77WTdrHPy3jFI0D5m

# Grafos
"""

import networkx as nx
import numpy as np
import heapdict as hd

class Grafo:
    def __init__(self):
        self.G={}
        self.visitado={}
  
    def inserta_dirigido(self,v1,v2=None,peso=None):
        if v1 not in self.G.keys():
            self.G[v1]={}
        if v2 is not None:
            self.G[v1][v2]=peso
        else:
            if v2 is not None and v2 not in self.G[v1]:
                self.G[v1][v2]=peso

    def inserta(self,v1,v2,peso=None):
        self.inserta_dirigido(v1,v2,peso)
        self.inserta_dirigido(v2,v1,peso)

  
    def __recorridoProfundidad(self,actual,lista):

        if actual is None:
            return
        if self.visitado[actual]:
            return
        self.visitado[actual]=True
        lista+=[actual]
        for vecino in self.G[actual]:
            self.__recorridoProfundidad(vecino,lista)

    def DFS(self):
## visitado = [False for v in G]
        for v in self.G:
            self.visitado[v]=False
        lista=[]
        for v in self.visitado:
            if not self.visitado[v]:
                self.__recorridoProfundidad(v,lista)
        return lista

    def __recorrdioAnchura(self, actual, cola):
        if actual is None:
            return
        if self.visitado[actual]:
            return
        self.visitado[actual]=True
        cola.append(actual)
    def BFS(self):
        for v in self.G:
            self.visitado[v]=False
        queue=[]
        aux = self.G.keys()
        primero = aux.pop(0)
        queue.append(primero)
        self.visitado[primero]
        lista=[]
        while queue:
            m = queue.pop(0)
            lista.append(m)
            for vecino in self.G[m]:
                self.__recorridoAnchura(vecino, queue)
        return lista


    def recorridoAncho(self, actual):
        for v in self.G:
            self.visitado[v]=False
        
    def Prim(self,v_ini):
        key=hd.heapdict()
        papa={}
        for v in self.G:
          key[v]=np.inf
          papa[v]=None
        key[v_ini]=0
    
        while len(key.keys())>0:
          nodo=key.popitem()[0]
          for vecino in self.G[nodo].keys():
            if vecino in key.keys() and self.G[nodo][vecino] < key[vecino]:
              key[vecino]=self.G[nodo][vecino]
              papa[vecino]=nodo
        return papa





    def Dijkstra(self,v_ini):
        key=hd.heapdict()
        papa={}
        for v in self.G:
          key[v]=np.inf
          papa[v]=None
        key[v_ini]=0
    
        while len(key.keys())>0:
          temp=key.popitem()
          nodo=temp[0]
          valor_ruta=temp[1]
          for vecino in self.G[nodo].keys():
            if vecino in key.keys() and valor_ruta+self.G[nodo][vecino] < key[vecino]:
              key[vecino]=valor_ruta+self.G[nodo][vecino]
              papa[vecino]=nodo
        return papa

    def profHamiltoniano(self,actual,recorrido):
        if(self.visitado[actual]):
          return False
        self.visitado[actual]=True
        recorrido.append(actual)
        if(len(recorrido)==len(self.G)):
          return True
        for u in self.G:
          res=self.profHamiltoniano(u,recorrido)
          if res:
            break
        recorrido[actual]=False
        recorrido.pop(actual)
        return res

    def Diametro(self):
       for v in self.G:
           self.visitado[v]=False
       distancias = []
       for v in self.G:
           distancias.append(distancia(v))
       if 0 in distancias:
           return "infinito"
       return max(distancias)

def distancia(self, actual):
       cola=[]
       cola.append((actual,0))
       self.visitados[actual] = True
       cont = 0
       while cola:
           tupla = cola.pop(0)
           nodo = tupla[0]
           cont = tupla[1]+1
           for vecino in self.G[nodo]:
               if not self.visitados[vecino]:
                   cola.append((vecino,cont))
                   self.visitados[vecino]=True
           return cont

miGrafo=Grafo()

miGrafo.inserta('v1','v2',6)
miGrafo.inserta('v2','v3')
miGrafo.inserta('v3','v4')
miGrafo.inserta_dirigido('solito')

miGrafo.G

gr1 = nx.Graph(miGrafo.G)

nx.draw(gr1, with_labels=True)

miGrafo.DFS()

g2=Grafo()
g2.inserta("a","b",4)
g2.inserta("a","h",8)
g2.inserta("b","c",8)
g2.inserta("b","h",11)
g2.inserta("c","d",7)
g2.inserta("c","f",4)
g2.inserta("c","i",2)
g2.inserta("d","e",9)
g2.inserta("d","f",14)
g2.inserta("e","f",10)
g2.inserta("f","g",2)
g2.inserta("g","h",1)
g2.inserta("g","i",6)
g2.inserta("h","i",7)

gr1 = nx.DiGraph(g2.G)# crear la el grafo en networkx
pos=nx.spring_layout(g2.G) # escoger un layout, como poner los v'ertices (puede ser en circulo, etc)
#pos=nx.circular_layout(g2.G)
nx.draw(gr1,pos, with_labels=True) # dibuja el grafo de networkx usando el layout que escogimos y que le ponga nombre a los vértices

# network x necesita un diccionario donde la llave es una pareja de véértices y el valor el peso de esa arista. La creamos de nuestera estrucutura usando un dict comprehension
# que es como un list comprehension pero con diccionario
edge_labels={(u,v):g2.G[u][v] for u,v in gr1.edges}


nx.draw_networkx_edge_labels(gr1,pos,edge_labels=edge_labels)

g2.Prim('a')

g2.Dijkstra('a')

g4=Grafo()
g4.inserta_dirigido("a","b",10)
g4.inserta_dirigido("a","d",5)
g4.inserta_dirigido("b","d",2)
g4.inserta_dirigido("b","c",1)
g4.inserta_dirigido("d","b",3)
g4.inserta_dirigido("d","c",9)
g4.inserta_dirigido("d","e",2)
g4.inserta_dirigido("e","c",6)
g4.inserta_dirigido("c","e",4)

gr1 = nx.DiGraph(g4.G)# crear la el grafo en networkx
pos=nx.spring_layout(g4.G) # escoger un layout, como poner los v'ertices (puede ser en circulo, etc)
#pos=nx.circular_layout(g2.G)
nx.draw(gr1,pos, with_labels=True) # dibuja el grafo de networkx usando el layout que escogimos y que le ponga nombre a los vértices

# network x necesita un diccionario donde la llave es una pareja de véértices y el valor el peso de esa arista. La creamos de nuestera estrucutura usando un dict comprehension
# que es como un list comprehension pero con diccionario
edge_labels={(u,v):g4.G[u][v] for u,v in gr1.edges}


nx.draw_networkx_edge_labels(gr1,pos,edge_labels=edge_labels)

g4.Dijkstra('a')

print(miGrafo.Diametro())